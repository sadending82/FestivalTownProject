// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SHOP_PACKETTABLE_SHOPTABLE_H_
#define FLATBUFFERS_GENERATED_SHOP_PACKETTABLE_SHOPTABLE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "Utilities_generated.h"

namespace PacketTable {
namespace ShopTable {

struct ShopListRequest;
struct ShopListRequestBuilder;

struct GoodsInfo;
struct GoodsInfoBuilder;

struct GoodsList;
struct GoodsListBuilder;

struct ShopListResponse;
struct ShopListResponseBuilder;

struct PurchaseGoodsRequest;
struct PurchaseGoodsRequestBuilder;

struct PurchaseGoodsResponse;
struct PurchaseGoodsResponseBuilder;

struct ShopListRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShopListRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ShopListRequestBuilder {
  typedef ShopListRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ShopListRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShopListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShopListRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShopListRequest> CreateShopListRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ShopListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GoodsInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GoodsInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_PRICE = 6,
    VT_IS_OWNED = 8
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  int32_t price() const {
    return GetField<int32_t>(VT_PRICE, 0);
  }
  bool is_owned() const {
    return GetField<uint8_t>(VT_IS_OWNED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PRICE, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_OWNED, 1) &&
           verifier.EndTable();
  }
};

struct GoodsInfoBuilder {
  typedef GoodsInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(GoodsInfo::VT_INDEX, index, 0);
  }
  void add_price(int32_t price) {
    fbb_.AddElement<int32_t>(GoodsInfo::VT_PRICE, price, 0);
  }
  void add_is_owned(bool is_owned) {
    fbb_.AddElement<uint8_t>(GoodsInfo::VT_IS_OWNED, static_cast<uint8_t>(is_owned), 0);
  }
  explicit GoodsInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GoodsInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GoodsInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GoodsInfo> CreateGoodsInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    int32_t price = 0,
    bool is_owned = false) {
  GoodsInfoBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_index(index);
  builder_.add_is_owned(is_owned);
  return builder_.Finish();
}

struct GoodsList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GoodsListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GOODS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsInfo>> *goods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsInfo>> *>(VT_GOODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GOODS) &&
           verifier.VerifyVector(goods()) &&
           verifier.VerifyVectorOfTables(goods()) &&
           verifier.EndTable();
  }
};

struct GoodsListBuilder {
  typedef GoodsList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_goods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsInfo>>> goods) {
    fbb_.AddOffset(GoodsList::VT_GOODS, goods);
  }
  explicit GoodsListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GoodsList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GoodsList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GoodsList> CreateGoodsList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsInfo>>> goods = 0) {
  GoodsListBuilder builder_(_fbb);
  builder_.add_goods(goods);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GoodsList> CreateGoodsListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsInfo>> *goods = nullptr) {
  auto goods__ = goods ? _fbb.CreateVector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsInfo>>(*goods) : 0;
  return PacketTable::ShopTable::CreateGoodsList(
      _fbb,
      goods__);
}

struct ShopListResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShopListResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_SHOP_LIST = 6
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsList>> *shop_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsList>> *>(VT_SHOP_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT, 4) &&
           VerifyOffset(verifier, VT_SHOP_LIST) &&
           verifier.VerifyVector(shop_list()) &&
           verifier.VerifyVectorOfTables(shop_list()) &&
           verifier.EndTable();
  }
};

struct ShopListResponseBuilder {
  typedef ShopListResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(ShopListResponse::VT_RESULT, result, 0);
  }
  void add_shop_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsList>>> shop_list) {
    fbb_.AddOffset(ShopListResponse::VT_SHOP_LIST, shop_list);
  }
  explicit ShopListResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShopListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShopListResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShopListResponse> CreateShopListResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsList>>> shop_list = 0) {
  ShopListResponseBuilder builder_(_fbb);
  builder_.add_shop_list(shop_list);
  builder_.add_result(result);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShopListResponse> CreateShopListResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    const std::vector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsList>> *shop_list = nullptr) {
  auto shop_list__ = shop_list ? _fbb.CreateVector<::flatbuffers::Offset<PacketTable::ShopTable::GoodsList>>(*shop_list) : 0;
  return PacketTable::ShopTable::CreateShopListResponse(
      _fbb,
      result,
      shop_list__);
}

struct PurchaseGoodsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PurchaseGoodsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct PurchaseGoodsRequestBuilder {
  typedef PurchaseGoodsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(PurchaseGoodsRequest::VT_INDEX, index, 0);
  }
  explicit PurchaseGoodsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PurchaseGoodsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PurchaseGoodsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PurchaseGoodsRequest> CreatePurchaseGoodsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0) {
  PurchaseGoodsRequestBuilder builder_(_fbb);
  builder_.add_index(index);
  return builder_.Finish();
}

struct PurchaseGoodsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PurchaseGoodsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_ITEM_INDEX = 6,
    VT_ITEM_AMOUNT = 8,
    VT_CURRENCY_INDEX = 10,
    VT_CURRENCY_AMOUNT = 12
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t item_index() const {
    return GetField<int32_t>(VT_ITEM_INDEX, 0);
  }
  int32_t item_amount() const {
    return GetField<int32_t>(VT_ITEM_AMOUNT, 0);
  }
  int32_t currency_index() const {
    return GetField<int32_t>(VT_CURRENCY_INDEX, 0);
  }
  int32_t currency_amount() const {
    return GetField<int32_t>(VT_CURRENCY_AMOUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<int32_t>(verifier, VT_ITEM_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_ITEM_AMOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_CURRENCY_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_CURRENCY_AMOUNT, 4) &&
           verifier.EndTable();
  }
};

struct PurchaseGoodsResponseBuilder {
  typedef PurchaseGoodsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(PurchaseGoodsResponse::VT_RESULT, result, 0);
  }
  void add_item_index(int32_t item_index) {
    fbb_.AddElement<int32_t>(PurchaseGoodsResponse::VT_ITEM_INDEX, item_index, 0);
  }
  void add_item_amount(int32_t item_amount) {
    fbb_.AddElement<int32_t>(PurchaseGoodsResponse::VT_ITEM_AMOUNT, item_amount, 0);
  }
  void add_currency_index(int32_t currency_index) {
    fbb_.AddElement<int32_t>(PurchaseGoodsResponse::VT_CURRENCY_INDEX, currency_index, 0);
  }
  void add_currency_amount(int32_t currency_amount) {
    fbb_.AddElement<int32_t>(PurchaseGoodsResponse::VT_CURRENCY_AMOUNT, currency_amount, 0);
  }
  explicit PurchaseGoodsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PurchaseGoodsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PurchaseGoodsResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PurchaseGoodsResponse> CreatePurchaseGoodsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t item_index = 0,
    int32_t item_amount = 0,
    int32_t currency_index = 0,
    int32_t currency_amount = 0) {
  PurchaseGoodsResponseBuilder builder_(_fbb);
  builder_.add_currency_amount(currency_amount);
  builder_.add_currency_index(currency_index);
  builder_.add_item_amount(item_amount);
  builder_.add_item_index(item_index);
  builder_.add_result(result);
  return builder_.Finish();
}

}  // namespace ShopTable
}  // namespace PacketTable

#endif  // FLATBUFFERS_GENERATED_SHOP_PACKETTABLE_SHOPTABLE_H_
