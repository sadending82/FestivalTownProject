// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PASS_PACKETTABLE_PASSTABLE_H_
#define FLATBUFFERS_GENERATED_PASS_PACKETTABLE_PASSTABLE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "Player_generated.h"
#include "Utilities_generated.h"

namespace PacketTable {
namespace PassTable {

struct UserPassStateRequest;
struct UserPassStateRequestBuilder;

struct UserPassState;
struct UserPassStateBuilder;

struct UserPassRewardState;
struct UserPassRewardStateBuilder;

struct UserMissionStateRequest;
struct UserMissionStateRequestBuilder;

struct UserMissionStateList;
struct UserMissionStateListBuilder;

struct UserMissionState;
struct UserMissionStateBuilder;

struct PassRewardRequest;
struct PassRewardRequestBuilder;

struct PassRewardResponse;
struct PassRewardResponseBuilder;

struct MissionCompleteRequest;
struct MissionCompleteRequestBuilder;

struct MissionCompleteResponse;
struct MissionCompleteResponseBuilder;

struct UserPassStateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserPassStateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PASS_INDEX = 4
  };
  int32_t pass_index() const {
    return GetField<int32_t>(VT_PASS_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PASS_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct UserPassStateRequestBuilder {
  typedef UserPassStateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pass_index(int32_t pass_index) {
    fbb_.AddElement<int32_t>(UserPassStateRequest::VT_PASS_INDEX, pass_index, 0);
  }
  explicit UserPassStateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserPassStateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserPassStateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserPassStateRequest> CreateUserPassStateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pass_index = 0) {
  UserPassStateRequestBuilder builder_(_fbb);
  builder_.add_pass_index(pass_index);
  return builder_.Finish();
}

struct UserPassState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserPassStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PASS_INDEX = 4,
    VT_PASS_TYPE = 6,
    VT_PASS_LEVEL = 8,
    VT_PASS_EXP = 10,
    VT_PASS_REWARD_STATE = 12
  };
  int32_t pass_index() const {
    return GetField<int32_t>(VT_PASS_INDEX, 0);
  }
  int32_t pass_type() const {
    return GetField<int32_t>(VT_PASS_TYPE, 0);
  }
  int32_t pass_level() const {
    return GetField<int32_t>(VT_PASS_LEVEL, 0);
  }
  int32_t pass_exp() const {
    return GetField<int32_t>(VT_PASS_EXP, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>> *pass_reward_state() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>> *>(VT_PASS_REWARD_STATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PASS_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_LEVEL, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_EXP, 4) &&
           VerifyOffset(verifier, VT_PASS_REWARD_STATE) &&
           verifier.VerifyVector(pass_reward_state()) &&
           verifier.VerifyVectorOfTables(pass_reward_state()) &&
           verifier.EndTable();
  }
};

struct UserPassStateBuilder {
  typedef UserPassState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pass_index(int32_t pass_index) {
    fbb_.AddElement<int32_t>(UserPassState::VT_PASS_INDEX, pass_index, 0);
  }
  void add_pass_type(int32_t pass_type) {
    fbb_.AddElement<int32_t>(UserPassState::VT_PASS_TYPE, pass_type, 0);
  }
  void add_pass_level(int32_t pass_level) {
    fbb_.AddElement<int32_t>(UserPassState::VT_PASS_LEVEL, pass_level, 0);
  }
  void add_pass_exp(int32_t pass_exp) {
    fbb_.AddElement<int32_t>(UserPassState::VT_PASS_EXP, pass_exp, 0);
  }
  void add_pass_reward_state(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>>> pass_reward_state) {
    fbb_.AddOffset(UserPassState::VT_PASS_REWARD_STATE, pass_reward_state);
  }
  explicit UserPassStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserPassState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserPassState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserPassState> CreateUserPassState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pass_index = 0,
    int32_t pass_type = 0,
    int32_t pass_level = 0,
    int32_t pass_exp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>>> pass_reward_state = 0) {
  UserPassStateBuilder builder_(_fbb);
  builder_.add_pass_reward_state(pass_reward_state);
  builder_.add_pass_exp(pass_exp);
  builder_.add_pass_level(pass_level);
  builder_.add_pass_type(pass_type);
  builder_.add_pass_index(pass_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserPassState> CreateUserPassStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pass_index = 0,
    int32_t pass_type = 0,
    int32_t pass_level = 0,
    int32_t pass_exp = 0,
    const std::vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>> *pass_reward_state = nullptr) {
  auto pass_reward_state__ = pass_reward_state ? _fbb.CreateVector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>>(*pass_reward_state) : 0;
  return PacketTable::PassTable::CreateUserPassState(
      _fbb,
      pass_index,
      pass_type,
      pass_level,
      pass_exp,
      pass_reward_state__);
}

struct UserPassRewardState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserPassRewardStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PASS_TYPE = 4,
    VT_LEVEL = 6,
    VT_IS_REWARDED = 8
  };
  int32_t pass_type() const {
    return GetField<int32_t>(VT_PASS_TYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool is_rewarded() const {
    return GetField<uint8_t>(VT_IS_REWARDED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PASS_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_LEVEL, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_REWARDED, 1) &&
           verifier.EndTable();
  }
};

struct UserPassRewardStateBuilder {
  typedef UserPassRewardState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pass_type(int32_t pass_type) {
    fbb_.AddElement<int32_t>(UserPassRewardState::VT_PASS_TYPE, pass_type, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(UserPassRewardState::VT_LEVEL, level, 0);
  }
  void add_is_rewarded(bool is_rewarded) {
    fbb_.AddElement<uint8_t>(UserPassRewardState::VT_IS_REWARDED, static_cast<uint8_t>(is_rewarded), 0);
  }
  explicit UserPassRewardStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserPassRewardState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserPassRewardState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserPassRewardState> CreateUserPassRewardState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pass_type = 0,
    int32_t level = 0,
    bool is_rewarded = false) {
  UserPassRewardStateBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_pass_type(pass_type);
  builder_.add_is_rewarded(is_rewarded);
  return builder_.Finish();
}

struct UserMissionStateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserMissionStateRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UserMissionStateRequestBuilder {
  typedef UserMissionStateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UserMissionStateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserMissionStateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserMissionStateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserMissionStateRequest> CreateUserMissionStateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  UserMissionStateRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UserMissionStateList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserMissionStateListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MISSION_STATE_LIST = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>> *mission_state_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>> *>(VT_MISSION_STATE_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MISSION_STATE_LIST) &&
           verifier.VerifyVector(mission_state_list()) &&
           verifier.VerifyVectorOfTables(mission_state_list()) &&
           verifier.EndTable();
  }
};

struct UserMissionStateListBuilder {
  typedef UserMissionStateList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mission_state_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>>> mission_state_list) {
    fbb_.AddOffset(UserMissionStateList::VT_MISSION_STATE_LIST, mission_state_list);
  }
  explicit UserMissionStateListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserMissionStateList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserMissionStateList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserMissionStateList> CreateUserMissionStateList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>>> mission_state_list = 0) {
  UserMissionStateListBuilder builder_(_fbb);
  builder_.add_mission_state_list(mission_state_list);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserMissionStateList> CreateUserMissionStateListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>> *mission_state_list = nullptr) {
  auto mission_state_list__ = mission_state_list ? _fbb.CreateVector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>>(*mission_state_list) : 0;
  return PacketTable::PassTable::CreateUserMissionStateList(
      _fbb,
      mission_state_list__);
}

struct UserMissionState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserMissionStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MISSION_INDEX = 4,
    VT_PROGRESS = 6,
    VT_IS_REWARDED = 8
  };
  int32_t mission_index() const {
    return GetField<int32_t>(VT_MISSION_INDEX, 0);
  }
  int32_t progress() const {
    return GetField<int32_t>(VT_PROGRESS, 0);
  }
  bool is_rewarded() const {
    return GetField<uint8_t>(VT_IS_REWARDED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MISSION_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PROGRESS, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_REWARDED, 1) &&
           verifier.EndTable();
  }
};

struct UserMissionStateBuilder {
  typedef UserMissionState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mission_index(int32_t mission_index) {
    fbb_.AddElement<int32_t>(UserMissionState::VT_MISSION_INDEX, mission_index, 0);
  }
  void add_progress(int32_t progress) {
    fbb_.AddElement<int32_t>(UserMissionState::VT_PROGRESS, progress, 0);
  }
  void add_is_rewarded(bool is_rewarded) {
    fbb_.AddElement<uint8_t>(UserMissionState::VT_IS_REWARDED, static_cast<uint8_t>(is_rewarded), 0);
  }
  explicit UserMissionStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserMissionState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserMissionState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserMissionState> CreateUserMissionState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mission_index = 0,
    int32_t progress = 0,
    bool is_rewarded = false) {
  UserMissionStateBuilder builder_(_fbb);
  builder_.add_progress(progress);
  builder_.add_mission_index(mission_index);
  builder_.add_is_rewarded(is_rewarded);
  return builder_.Finish();
}

struct PassRewardRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PassRewardRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PASS_INDEX = 4,
    VT_PASS_TYPE = 6,
    VT_PASS_LEVEL = 8
  };
  int32_t pass_index() const {
    return GetField<int32_t>(VT_PASS_INDEX, 0);
  }
  int32_t pass_type() const {
    return GetField<int32_t>(VT_PASS_TYPE, 0);
  }
  int32_t pass_level() const {
    return GetField<int32_t>(VT_PASS_LEVEL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PASS_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_LEVEL, 4) &&
           verifier.EndTable();
  }
};

struct PassRewardRequestBuilder {
  typedef PassRewardRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pass_index(int32_t pass_index) {
    fbb_.AddElement<int32_t>(PassRewardRequest::VT_PASS_INDEX, pass_index, 0);
  }
  void add_pass_type(int32_t pass_type) {
    fbb_.AddElement<int32_t>(PassRewardRequest::VT_PASS_TYPE, pass_type, 0);
  }
  void add_pass_level(int32_t pass_level) {
    fbb_.AddElement<int32_t>(PassRewardRequest::VT_PASS_LEVEL, pass_level, 0);
  }
  explicit PassRewardRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PassRewardRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PassRewardRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PassRewardRequest> CreatePassRewardRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pass_index = 0,
    int32_t pass_type = 0,
    int32_t pass_level = 0) {
  PassRewardRequestBuilder builder_(_fbb);
  builder_.add_pass_level(pass_level);
  builder_.add_pass_type(pass_type);
  builder_.add_pass_index(pass_index);
  return builder_.Finish();
}

struct PassRewardResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PassRewardResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PASS_INDEX = 6,
    VT_PASS_TYPE = 8,
    VT_PASS_LEVEL = 10,
    VT_REWARD_ITEM_INDEX = 12,
    VT_REWARD_ITEM_AMOUNT = 14
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t pass_index() const {
    return GetField<int32_t>(VT_PASS_INDEX, 0);
  }
  int32_t pass_type() const {
    return GetField<int32_t>(VT_PASS_TYPE, 0);
  }
  int32_t pass_level() const {
    return GetField<int32_t>(VT_PASS_LEVEL, 0);
  }
  int32_t reward_item_index() const {
    return GetField<int32_t>(VT_REWARD_ITEM_INDEX, 0);
  }
  int32_t reward_item_amount() const {
    return GetField<int32_t>(VT_REWARD_ITEM_AMOUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_LEVEL, 4) &&
           VerifyField<int32_t>(verifier, VT_REWARD_ITEM_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_REWARD_ITEM_AMOUNT, 4) &&
           verifier.EndTable();
  }
};

struct PassRewardResponseBuilder {
  typedef PassRewardResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(PassRewardResponse::VT_RESULT, result, 0);
  }
  void add_pass_index(int32_t pass_index) {
    fbb_.AddElement<int32_t>(PassRewardResponse::VT_PASS_INDEX, pass_index, 0);
  }
  void add_pass_type(int32_t pass_type) {
    fbb_.AddElement<int32_t>(PassRewardResponse::VT_PASS_TYPE, pass_type, 0);
  }
  void add_pass_level(int32_t pass_level) {
    fbb_.AddElement<int32_t>(PassRewardResponse::VT_PASS_LEVEL, pass_level, 0);
  }
  void add_reward_item_index(int32_t reward_item_index) {
    fbb_.AddElement<int32_t>(PassRewardResponse::VT_REWARD_ITEM_INDEX, reward_item_index, 0);
  }
  void add_reward_item_amount(int32_t reward_item_amount) {
    fbb_.AddElement<int32_t>(PassRewardResponse::VT_REWARD_ITEM_AMOUNT, reward_item_amount, 0);
  }
  explicit PassRewardResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PassRewardResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PassRewardResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PassRewardResponse> CreatePassRewardResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t pass_index = 0,
    int32_t pass_type = 0,
    int32_t pass_level = 0,
    int32_t reward_item_index = 0,
    int32_t reward_item_amount = 0) {
  PassRewardResponseBuilder builder_(_fbb);
  builder_.add_reward_item_amount(reward_item_amount);
  builder_.add_reward_item_index(reward_item_index);
  builder_.add_pass_level(pass_level);
  builder_.add_pass_type(pass_type);
  builder_.add_pass_index(pass_index);
  builder_.add_result(result);
  return builder_.Finish();
}

struct MissionCompleteRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MissionCompleteRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MISSION_INDEX = 4
  };
  int32_t mission_index() const {
    return GetField<int32_t>(VT_MISSION_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MISSION_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct MissionCompleteRequestBuilder {
  typedef MissionCompleteRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mission_index(int32_t mission_index) {
    fbb_.AddElement<int32_t>(MissionCompleteRequest::VT_MISSION_INDEX, mission_index, 0);
  }
  explicit MissionCompleteRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MissionCompleteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MissionCompleteRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MissionCompleteRequest> CreateMissionCompleteRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mission_index = 0) {
  MissionCompleteRequestBuilder builder_(_fbb);
  builder_.add_mission_index(mission_index);
  return builder_.Finish();
}

struct MissionCompleteResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MissionCompleteResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PASS_INDEX = 6,
    VT_MISSION_INDEX = 8,
    VT_PASS_LEVEL = 10,
    VT_PASS_EXP = 12,
    VT_REWARD_ITEM_INDEX = 14,
    VT_REWARD_ITEM_AMOUNT = 16
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t pass_index() const {
    return GetField<int32_t>(VT_PASS_INDEX, 0);
  }
  int32_t mission_index() const {
    return GetField<int32_t>(VT_MISSION_INDEX, 0);
  }
  int32_t pass_level() const {
    return GetField<int32_t>(VT_PASS_LEVEL, 0);
  }
  int32_t pass_exp() const {
    return GetField<int32_t>(VT_PASS_EXP, 0);
  }
  int32_t reward_item_index() const {
    return GetField<int32_t>(VT_REWARD_ITEM_INDEX, 0);
  }
  int32_t reward_item_amount() const {
    return GetField<int32_t>(VT_REWARD_ITEM_AMOUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_MISSION_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_LEVEL, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_EXP, 4) &&
           VerifyField<int32_t>(verifier, VT_REWARD_ITEM_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_REWARD_ITEM_AMOUNT, 4) &&
           verifier.EndTable();
  }
};

struct MissionCompleteResponseBuilder {
  typedef MissionCompleteResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(MissionCompleteResponse::VT_RESULT, result, 0);
  }
  void add_pass_index(int32_t pass_index) {
    fbb_.AddElement<int32_t>(MissionCompleteResponse::VT_PASS_INDEX, pass_index, 0);
  }
  void add_mission_index(int32_t mission_index) {
    fbb_.AddElement<int32_t>(MissionCompleteResponse::VT_MISSION_INDEX, mission_index, 0);
  }
  void add_pass_level(int32_t pass_level) {
    fbb_.AddElement<int32_t>(MissionCompleteResponse::VT_PASS_LEVEL, pass_level, 0);
  }
  void add_pass_exp(int32_t pass_exp) {
    fbb_.AddElement<int32_t>(MissionCompleteResponse::VT_PASS_EXP, pass_exp, 0);
  }
  void add_reward_item_index(int32_t reward_item_index) {
    fbb_.AddElement<int32_t>(MissionCompleteResponse::VT_REWARD_ITEM_INDEX, reward_item_index, 0);
  }
  void add_reward_item_amount(int32_t reward_item_amount) {
    fbb_.AddElement<int32_t>(MissionCompleteResponse::VT_REWARD_ITEM_AMOUNT, reward_item_amount, 0);
  }
  explicit MissionCompleteResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MissionCompleteResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MissionCompleteResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MissionCompleteResponse> CreateMissionCompleteResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t pass_index = 0,
    int32_t mission_index = 0,
    int32_t pass_level = 0,
    int32_t pass_exp = 0,
    int32_t reward_item_index = 0,
    int32_t reward_item_amount = 0) {
  MissionCompleteResponseBuilder builder_(_fbb);
  builder_.add_reward_item_amount(reward_item_amount);
  builder_.add_reward_item_index(reward_item_index);
  builder_.add_pass_exp(pass_exp);
  builder_.add_pass_level(pass_level);
  builder_.add_mission_index(mission_index);
  builder_.add_pass_index(pass_index);
  builder_.add_result(result);
  return builder_.Finish();
}

}  // namespace PassTable
}  // namespace PacketTable

#endif  // FLATBUFFERS_GENERATED_PASS_PACKETTABLE_PASSTABLE_H_
