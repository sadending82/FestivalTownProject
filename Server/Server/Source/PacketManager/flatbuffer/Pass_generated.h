// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PASS_PACKETTABLE_PASSTABLE_H_
#define FLATBUFFERS_GENERATED_PASS_PACKETTABLE_PASSTABLE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "Player_generated.h"
#include "Utilities_generated.h"

namespace PacketTable {
namespace PassTable {

struct UserPassState;
struct UserPassStateBuilder;

struct UserPassRewardState;
struct UserPassRewardStateBuilder;

struct UserMissionStateList;
struct UserMissionStateListBuilder;

struct UserMissionState;
struct UserMissionStateBuilder;

struct UserPassState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserPassStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PASS_INDEX = 4,
    VT_PASS_TYPE = 6,
    VT_PASS_LEVEL = 8,
    VT_PASS_EXP = 10,
    VT_PASS_REWARD_STATE = 12
  };
  int32_t pass_index() const {
    return GetField<int32_t>(VT_PASS_INDEX, 0);
  }
  int32_t pass_type() const {
    return GetField<int32_t>(VT_PASS_TYPE, 0);
  }
  int32_t pass_level() const {
    return GetField<int32_t>(VT_PASS_LEVEL, 0);
  }
  int32_t pass_exp() const {
    return GetField<int32_t>(VT_PASS_EXP, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>> *pass_reward_state() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>> *>(VT_PASS_REWARD_STATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PASS_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_LEVEL, 4) &&
           VerifyField<int32_t>(verifier, VT_PASS_EXP, 4) &&
           VerifyOffset(verifier, VT_PASS_REWARD_STATE) &&
           verifier.VerifyVector(pass_reward_state()) &&
           verifier.VerifyVectorOfTables(pass_reward_state()) &&
           verifier.EndTable();
  }
};

struct UserPassStateBuilder {
  typedef UserPassState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pass_index(int32_t pass_index) {
    fbb_.AddElement<int32_t>(UserPassState::VT_PASS_INDEX, pass_index, 0);
  }
  void add_pass_type(int32_t pass_type) {
    fbb_.AddElement<int32_t>(UserPassState::VT_PASS_TYPE, pass_type, 0);
  }
  void add_pass_level(int32_t pass_level) {
    fbb_.AddElement<int32_t>(UserPassState::VT_PASS_LEVEL, pass_level, 0);
  }
  void add_pass_exp(int32_t pass_exp) {
    fbb_.AddElement<int32_t>(UserPassState::VT_PASS_EXP, pass_exp, 0);
  }
  void add_pass_reward_state(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>>> pass_reward_state) {
    fbb_.AddOffset(UserPassState::VT_PASS_REWARD_STATE, pass_reward_state);
  }
  explicit UserPassStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserPassState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserPassState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserPassState> CreateUserPassState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pass_index = 0,
    int32_t pass_type = 0,
    int32_t pass_level = 0,
    int32_t pass_exp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>>> pass_reward_state = 0) {
  UserPassStateBuilder builder_(_fbb);
  builder_.add_pass_reward_state(pass_reward_state);
  builder_.add_pass_exp(pass_exp);
  builder_.add_pass_level(pass_level);
  builder_.add_pass_type(pass_type);
  builder_.add_pass_index(pass_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserPassState> CreateUserPassStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pass_index = 0,
    int32_t pass_type = 0,
    int32_t pass_level = 0,
    int32_t pass_exp = 0,
    const std::vector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>> *pass_reward_state = nullptr) {
  auto pass_reward_state__ = pass_reward_state ? _fbb.CreateVector<::flatbuffers::Offset<PacketTable::PassTable::UserPassRewardState>>(*pass_reward_state) : 0;
  return PacketTable::PassTable::CreateUserPassState(
      _fbb,
      pass_index,
      pass_type,
      pass_level,
      pass_exp,
      pass_reward_state__);
}

struct UserPassRewardState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserPassRewardStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_REWARDED = 4
  };
  const ::flatbuffers::Vector<uint8_t> *is_rewarded() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_IS_REWARDED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IS_REWARDED) &&
           verifier.VerifyVector(is_rewarded()) &&
           verifier.EndTable();
  }
};

struct UserPassRewardStateBuilder {
  typedef UserPassRewardState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_is_rewarded(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> is_rewarded) {
    fbb_.AddOffset(UserPassRewardState::VT_IS_REWARDED, is_rewarded);
  }
  explicit UserPassRewardStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserPassRewardState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserPassRewardState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserPassRewardState> CreateUserPassRewardState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> is_rewarded = 0) {
  UserPassRewardStateBuilder builder_(_fbb);
  builder_.add_is_rewarded(is_rewarded);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserPassRewardState> CreateUserPassRewardStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *is_rewarded = nullptr) {
  auto is_rewarded__ = is_rewarded ? _fbb.CreateVector<uint8_t>(*is_rewarded) : 0;
  return PacketTable::PassTable::CreateUserPassRewardState(
      _fbb,
      is_rewarded__);
}

struct UserMissionStateList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserMissionStateListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MISSION_STATE_LIST = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>> *mission_state_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>> *>(VT_MISSION_STATE_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MISSION_STATE_LIST) &&
           verifier.VerifyVector(mission_state_list()) &&
           verifier.VerifyVectorOfTables(mission_state_list()) &&
           verifier.EndTable();
  }
};

struct UserMissionStateListBuilder {
  typedef UserMissionStateList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mission_state_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>>> mission_state_list) {
    fbb_.AddOffset(UserMissionStateList::VT_MISSION_STATE_LIST, mission_state_list);
  }
  explicit UserMissionStateListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserMissionStateList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserMissionStateList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserMissionStateList> CreateUserMissionStateList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>>> mission_state_list = 0) {
  UserMissionStateListBuilder builder_(_fbb);
  builder_.add_mission_state_list(mission_state_list);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserMissionStateList> CreateUserMissionStateListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>> *mission_state_list = nullptr) {
  auto mission_state_list__ = mission_state_list ? _fbb.CreateVector<::flatbuffers::Offset<PacketTable::PassTable::UserMissionState>>(*mission_state_list) : 0;
  return PacketTable::PassTable::CreateUserMissionStateList(
      _fbb,
      mission_state_list__);
}

struct UserMissionState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserMissionStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MISSION_INDEX = 4,
    VT_PROGRESS = 6,
    VT_IS_REWARDED = 8
  };
  int32_t mission_index() const {
    return GetField<int32_t>(VT_MISSION_INDEX, 0);
  }
  int32_t progress() const {
    return GetField<int32_t>(VT_PROGRESS, 0);
  }
  bool is_rewarded() const {
    return GetField<uint8_t>(VT_IS_REWARDED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MISSION_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PROGRESS, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_REWARDED, 1) &&
           verifier.EndTable();
  }
};

struct UserMissionStateBuilder {
  typedef UserMissionState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mission_index(int32_t mission_index) {
    fbb_.AddElement<int32_t>(UserMissionState::VT_MISSION_INDEX, mission_index, 0);
  }
  void add_progress(int32_t progress) {
    fbb_.AddElement<int32_t>(UserMissionState::VT_PROGRESS, progress, 0);
  }
  void add_is_rewarded(bool is_rewarded) {
    fbb_.AddElement<uint8_t>(UserMissionState::VT_IS_REWARDED, static_cast<uint8_t>(is_rewarded), 0);
  }
  explicit UserMissionStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserMissionState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserMissionState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserMissionState> CreateUserMissionState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mission_index = 0,
    int32_t progress = 0,
    bool is_rewarded = false) {
  UserMissionStateBuilder builder_(_fbb);
  builder_.add_progress(progress);
  builder_.add_mission_index(mission_index);
  builder_.add_is_rewarded(is_rewarded);
  return builder_.Finish();
}

}  // namespace PassTable
}  // namespace PacketTable

#endif  // FLATBUFFERS_GENERATED_PASS_PACKETTABLE_PASSTABLE_H_
